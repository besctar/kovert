package uy.kohesive.kovert.core

enum class HttpVerb { GET, POST, PUT, DELETE, PATCH, HEAD }


/**
 * Alias a HTTP verb to a list of method prefixes (camel case, first segment of the method name)
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.CLASS)
annotation class VerbAlias(val prefix: String, val verb: HttpVerb, val successStatusCode: Int = 200)

@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.CLASS)
annotation class VerbAliases(vararg val value: VerbAlias)

/**
 * Override prefix with a specific HTTP Verb.  By default the prefix part of the method name is skipped and ingored for both the verb and not included in the path.
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
annotation class Verb(val verb: HttpVerb, val successStatusCode: Int = 200, val skipPrefix: Boolean = true)

/**
 * Override camel case parsing to generate location by providing a specific location (can include path params "/something/:parmName/other").  The HTTP Verb is stil
 * extracted from the method name using aliases unless a specific Verb annotation is included.
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
annotation class Location(val path: String)


/**
 * Set a view to be used to render the response object returned by the function, requires that a view engine is registered
 * that can recognize the type of the view.
 *
 * @param template the template to render, the template engine is automatically selected from the template name.  The template can be ommitted if an object of type ModelAndRenderTemplate (or promise of one) is returned which overrides the template name
 * @param contentType to override the content-type header generated by the template engine (or the default of "text/html" if the string is blank)
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY)
annotation class Rendered(val template: String = "", val contentType: String = "")


/**
 * Set list of authorities for accessing a resource, the auth handler must be in place to authorize the resource against
 * the current user.  This can be placed on the controller, or individual resource within the controller.
 *
 * Roles are OR within one annotation unless you set the mode to AuthorityMode.ALL
 *
 * @param roles any of these roles authorize using the resource.  No role means "only logged in is ok"
 * @param mode whether ALL or ANY of the roles must match, defaults to ANY
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY, AnnotationTarget.CLASS)
annotation class Authority(vararg val roles: String, val mode: AuthorityMode = AuthorityMode.ANY)

enum class AuthorityMode { ALL, ANY }

